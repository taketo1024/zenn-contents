---
title: "6-1. 積の型"
---

プログラミング言語においてふたつの型の積を実装するための正攻法はペアを使うことだ．ペアは Haskell ではプリミティブな型コンストラクタだし， C++ では標準ライブラリに少し複雑なテンプレートとして用意されている．

![](https://storage.googleapis.com/zenn-user-upload/f4ebf0115ddbc664258dee84.jpg)

ペアは入れ替え可能とは限らない． `(Int, Bool)` と `(Bool, Int)` は保持する情報はおなじだが，単純に入れ替えることはできない．しかし以下に示す `swap` 関数で定義する同型射の下では可換である．（ `swap` の逆射は `swap` 自身だ．）

```
swap :: (a, b) -> (b, a)
swap (x, y) = (y, x)
```

つまりこの二つのペアは，同じデータを違うフォーマットで見ているだけだと思ってもかまわない．ビックエンディアンとリトルエンディアンのようなものだ．

任意の個数の型を積にするにはペアを入れ子にしてもよいが，タプルを使ってもよい．つまり，ペアをどう入れ子にしても同型だということだ．3つの型 `a`, `b`, `c` をこの順の積にしたければ2つの方法がある．

```
((a, b), c)
```

と，

```
(a, (b, c))
```

だ．これらはもちろん同じではない（たとえば一方のために作られた関数にもう一方を与えても動作しない）が，その要素は一対一に対応している．両者をマッピングする関数は次のように書けて，

```
alpha :: ((a, b), c) -> (a, (b, c))
alpha ((x, y), z) = (x, (y, z))
```

この関数 `alpha` には逆射 `alpha_inv` が存在するので，

```
alpha_inv :: (a, (b c)) -> ((a, b), c)
alpha_inv (x, (y, z)) = ((x, y), z)
```

この入れ子になった2種類のペアは同型だとわかる．パッキングの仕方が違うだけで同じデータだということだ．

ここまで積の型について見てきたが，これを型の間の二項演算と解釈するとどうなるだろうか．先ほどの同型が，モノイドの結合律にみえてこないだろうか．

$$ (a * b) * c = a * (b * c) $$

モノイドと違うのは，ここでの等号はあくまで「同型を除いて等しい」，という意味だというところだ．

厳密な意味での「等しさ」ではなく同型を「等しい」と捉えることを許すなら，もう一歩踏み込んで， unit 型 `()` が先ほどの積において 1 の役割を果たしていることが見えてくる．実際，ある型 `a` とユニットをペアにしても情報はなにも変化しない．つまり型

```
(a, ())
```

は `a` と同型だ．ここでの同型射は次の2つの射になる．

```
rho :: (a, ()) -> a
rho (x, ()) = x
```

```
rho_inv :: a -> (a, ())
rho_inv x = (x, ())
```

以上の性質から，集合の圏 $\mathbf{Set}$ は **モノイダル圏** (monoidal category) だと言える．モノイダル圏とは，複数の対象の乗算（ここではカルテジアン積）できるという意味でモノイドになっている圏のことである．ここではもう少しだけモノイダル圏について触れるが，完全な定義は後で行う．

Haskell で直積型を定義するのには，ペアを使うより一般的な方法がある．これは，とくに直和型と組み合わせるときに便利な方法だ．それは，複数の引数を取るコンストラクタに名前をつけて使うというやり方である．たとえばペアを使う代わりに，次のように `Pair` を定義する．

```Haskell
data Pair a b = P a b
```
ここで `Pair a b` は型パラメータ `a` と `b` を引数にとる型で， `P` はデータコンストラクタである．`P` に適切な型をふたつ渡すことでペアの型を定義するというのが `Pair` の働きだ．たとえば `String` と `Bool` のペアとして `stmt` を定義してみよう．

```Haskell
stmt :: Pair String Bool
stmt = P "This statement is" False
```

`Pair` 定義の段階では型パラメータ `a`, `b` としていたものを，この一行目の型宣言で String と Bool に置きかえている．二行目では具体的な文字列と真偽値をデータコンストラクタ `P` に与えて，具体的な `stmt` を生成している．型コンストラクタで型を生成し，データコンストラクタで値を生成しているということだ．

Haskell では型とデータの名前空間は分かれているので，同じ名前が使える．

```Haskell
data Pair a b = Pair a b
```

これをよく眺めると，ビルトインのペア型もこの一種に見えてくるだろう． `Pair` を二項演算子 `(,)` に置き換えるだけだ．事実， `(,)` をほかの名前付きコンストラクタのように前置記法で使うこともできる．

```Haskell
stmt = (,) "This statement is" False
```

さらに言えば， `(,,)` などとすれば数を増やせる．

一般的なペアやタプルの代わりに，積の型に特定の名前を与えることもできる． `String` と `Bool` の積であればこうなる．

```Haskell
data Stmt = Stmt String Bool
```

これは積であるという点ではペアと変わらないが，専用の名前とコンストラクタが与えられている．このように宣言する利点は，中身は同じでも意味合いや機能の異なるペアを区別できるということだ．名前を与えれば，間違って代入することもない．

タプルや多くの引数をとるコンストラクタは複雑でバグを産みがちだ．どのコンポーネントが何を意味しているかをすべて把握しておかねばならない．そこに名前をつけるというのは大体においてよい解決策になる．各フィールドに名前をつけた積の型は，Haskell ではレコード，C ではs `struct` と呼ばれている．



（和訳：[@takase](https://zenn.dev/takase)）