---
title: "13.1 Haskellでの自由モノイド"
---


Haskellでの2元集合は`Bool`型と等価であり、この集合から生成される自由モノイドは`[Bool]`型(`Bool`のリスト)と等価である(無限リストにまつわる問題はあえて無視することにする)。

Haskellでのモノイドは型クラスで定義される:


A monoid in Haskell is defined by the type class:

```haskell
class Monoid m where
    mempty :: m
    mappend :: m -> m -> m
```

これは、`Monoid`は`mempty`とよばれる中立な元と、(かけ算の)2引数関数`mappend`を持たねばならないと言っているだけである。単位元と結合則はHaskellでは表現できないので、モノイドが具体化されるたびに毎回プログラマによって検証されなければならない。

どんな型のリストもモノイドをなすという事実は、次のインスタンス定義に書かれている:
```haskell
instance Monoid [a] where
    mempty = []
    mappend = (++)
```

これは、空リスト`[]`は単位元であり、リスト結合`(++)`は例の2引数操作であると言っている。

ここまで見てきたように、`a`型のリストは集合`a`が生成元たちになっている自由モノイドに対応する。自然数集合をかけ算とともに考えたものは自由モノイドではない。なぜなら、たくさんの積を同一視してしまっているからだ。例えば次を比較してみよう:

```
2 * 3 = 6
[2] ++ [3] = [2, 3] // [6]ではない
```

自由モノイドは簡単だったが、問題はこの自由な構成を(対象の中身を見ることが許されていない)圏論でもできるのだろうかということだ。ここで我等の働き者を使おう: 普遍構成だ。

2つ目の面白い問題は、どんなモノイドもある自由モノイドから、モノイドの法則で要求されている最小の元たちよりたくさんの元たちを同一視することによって得られるのだろうか、ということだ。これについてはあとで、自由構成から即座に従うことを見よう。


（和訳：[@ashiato45](https://twitter.com/ashiato45)）
