---
title: "9.5 指数対象と代数データ型"
---

関数型を指数対象として解釈するのは，代数的データ型にとってはとても都合がよい．高校までの代数で習った数字の $0$ や $1$ や和，積，そしてべき乗は，そのまま双カルテジアン閉圏でも同じで，それぞれ始対象，終対象，積，余積，指数対象に対応する．証明するにはまだ道具立てが足りない（随伴や米田の補題が必要）が，それでもこの対応関係は，直観的な理解の助けになるだろう．

# 0乗

$$ a^0 = 1 $$

圏論的には， $0$ が始対象， $1$ が終対象，等号が同型，にそれぞれ対応する．そしてべき乗は内部 hom 対象だ．べき乗のなかでも特に0乗は，始対象から任意の対象 $a$ への射の集合に対応する． 始対象の定義から，このような射はただ一つ存在する^[There is exactly one]ので， この hom 集合 $\mathbf{C}(0,a)$ は「要素が 1 つの集合」，つまりシングルトン（単集合）である．シングルトンは集合の圏 $\mathbf{Set}$ の終対象なので， hom 集合 $\mathbf{C}(0,a)$ がシングルトンであるという性質はあらゆる双カルテジアン閉圏で成り立つ．

同じことをHaskell で表現するには， $0$ を `Void` ， $1$ を unit 型 `()` ，べき乗を関数型，にそれぞれ置き換えればよい．これによれば，先ほどの式は 「 `Void` から任意の型への関数は Unit 型（つまりシングルトン）と等価である」ということになる．言い換えれば， `Void -> a` という型を持つ関数はただ一つ存在する，といことだ．これはまさに以前登場した `absurd` だ^[[2.6 参照](https://zenn.dev/taketo1024/books/850b20937af93b/viewer/2-6)]．

ただ， Haskell 的な解釈に意味があるかというと微妙なところだ．理由は2つあって，ひとつめは Haskell ではすべての型は「何らかの計算結果^[訳注： the bottom]」か，「無限ループに陥ったという結果」というある種の値を持つので，真の意味で「からっぽ」の型が存在しないということだ．もうひとつは， `absurd` の実装はどう頑張って実装したところで，だれにも使えないということだ．そもそも何も返ってこないのだから，どんな値を `absurd` に渡しても意味がない．

# 1のべき乗

$$ 1^a = 1 $$

これは「任意の対象から終対象への射はただ一つ存在する」という終対象の定義そのものであることがわかるだろう． $\mathbf{Set}$ として解釈したときとまったく同じだ．より一般的には， $a$ から終対象への内部 hom 対象は，終対象自身と同型，という意味になる．

Haskell では，任意の型から `unit` への関数はただ一つだけ存在する．以前も登場した `unit` だ．あるいは `const` に `()` を部分適用したもの，と思ってもよい．

# 1 乗

$$ a ^ 1 = a $$

これは「終対象からの射は，対象 `a` の中身を1つ選ぶ作業とおなじ」という意味になる．このような射の集合は，対象それ自体と同型だ．集合の圏 $\mathbf{Set}$ では集合の要素の間の同型に対応し， Haskell では要素を選ぶ関数 `() -> a` に対応する．

# 和のべき乗

$$ a ^ {b+c} = a ^ b \times a ^ c $$

圏論的には，余積のべき乗はべき乗の積と同型，という意味になる． Haskell ではこの同型はとても実用的で，二つの型の直和からの関数は，それぞれの型からの関数2つと等価であるということだ．たとえば直和を引数に取る関数を定義することを考えてみる．この場合， `case` 文を含む関数をひとつ定義する代わりに，それぞれの型コンストラクタを扱う関数に分割するのだ．したがって，関数はふたつ（あるいはそれ以上）に分割されることになる．たとえば直和型 `(Either Int Double)` を引数にとる関数 `f` を考えてみよう．

```haskell
f :: Either Int Double -> String
```

これは `Int` をとる関数と `Double` を取る関数に分割して定義できる．

```haskell
f (Left n) = if n < 0 then "Negative int" else "Positive int"
f (Right x) = if x < 0.0 then "Negative double" else "Positive double"
```

ここでの `n` は `Int` で，`x` は `Double` だ．

# べき乗のべき乗

$$ \left( a^b \right)^c = a ^ {b \times c} $$

これはカリー化を指数対象を使って表現したものだ．「関数を返す関数」と，「積を取る関数（つまり二つの引数を取る関数）」が等価であると言っている．

# 積のべき乗

$$ \left( a \times b \right)^c = a ^ c + b ^ c $$

Haskell 視点で言うなら，ペアを返す関数は，それぞれを返す関数のペアと等価である．

このように高校での代数の等式が圏論に持ち上げられ，しかもそれが関数型プログラミングにおいて実用的な意味をもつというのは，なんと素晴らしいことだろうか．

（和訳：[@takase](https://zenn.dev/takase)）