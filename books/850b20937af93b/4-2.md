---
title: "4.2 Haskell の Writer"
---

Haskell はコンパイラがいろいろ助けてくれるので，同じことがもう少し簡潔に記述できる．手始めに `Writer` 型を定義しよう．

```Haskell
type Writer a = (a, String)
```

これは型エイリアスの定義で， C++ の `typedef` (または `using`) と同じものだ． `Writer` 型は型変数 `a` でパラメータ化されており，前節の `a` と `String` のペアに相当する．Haskell でのペアの記法は，括弧で囲ってカンマで区切るというシンプルなものだ．

すると「この圏」の射は，任意の型を取って `Writer` 型を返す関数といえる．

```haskell
a -> Writer b
```

合成には一風変わった中置演算子を使う．この演算子はしばしば "フィッシュ（魚）" とも呼ばれる．

```haskell
(>=>) :: (a -> Writer b) -> (b -> Writer c) -> (a -> Writer c)
```

この演算子はふたつの関数をとり，関数をひとつ返す．引数のひとつめの型は `(a -> Writer b)`，ふたつめの型は `(b -> Writer c)` ，そして返り値の型が `(a -> Writer c)` である．

この中置演算子の定義はこうなる．ふたつの引数 `m1`，`m2` が魚記号の前後に置かれる．

```haskell
m1 >=> m2 = \x ->
    let (y, s1) = m1 x
        (z, s2) = m2 y
    in (z, s1 ++ s2)
```

返り値は引数がひとつ（`x`）の無名関数である．Haskell では無名関数にバックスラッシュを使うのだが，これはギリシャ文字の $\lambda$ の一部を省略したものだと思ってほしい．

`let` 式は補助的な変数を宣言するのに使っている． `m1` を呼び出した結果をパターンマッチングで `(y, s1)` に代入し，その `y` をつかって `m2` を呼び出し，さらにその結果を `(z, s2)` に代入している．

アクセサを使う C++ と違って， Haskell ではペアのパターンマッチングを使うことが多いのだが，これらの関係はとても素直なものだ．

`let` 式の結果は `in` 節で指定されているペアで，その第1要素が `z` で第2要素がふたつの文字列を連結した `s1++s2` だ．

つづいて「この圏」の恒等射も定義しておこう．理由はおいおい明らかにするが，名前は `return` とさせてもらう．

```haskell
return :: a -> Writer a
return x = (x, "")
```

あとは装飾付きの `upCase` と `toWords` の Haskell 版を作れば完成だ．

```haskell
upCase :: String -> Writer String
upCase s = (map toUpper s, "upCase ")

toWords :: String -> Writer [String]
toWords s = (words s, "toWords ")
```

`map` 関数は C++ の `transform` に相当し，文字列を取る関数 `toUpper` を文字列 `s` に適用するのに使われる．補助関数 `words` は標準ライブラリ Prelude で定義されているものを使った．

これで準備は整った．フィッシュ演算子を使えば，次のようにふたつの関数の合成ができる．

```haskell
process :: String -> Writer [String]
process = upCase >=> toWords
```

（和訳：[@takase](https://zenn.dev/takase)）