---
title: "6-4. 型の代数"
---

直積型と直和型は，それぞれ単独でも便利なデータ構造を定義できるが，その真骨頂は両者の組み合わせにある．合成のべき乗についてもう一度考えてみよう．

今までに得ている知見をまとめてみよう．議論の対象としてきたのは， `Void` と普通の要素の直和型と，ユニット型 `()` と普通の要素の直積型，という型システムの上の可換なモノイダル構造なのだった．これらを，加算や乗算のアナロジーとして考えてみると， `Void` は数字の 0 に， `()` は数字の 1 に対応付けられる．

このアナロジーをもう少し進めてみよう．例えば， 0 との積は 0 になるだろうか？ つまり直積型の片方が `Void` だった場合， `Void` に同型になるだろうか？ `Int` と `Void` のペアはどうなるだろう？

ペアを作るには2つの値が必要だ．整数の値はすぐに思いつくだろうが， `Void` 型には値が存在しない．よっていかなる型 `a` についても `(a, Void)` は値が存在せず，つまりそれは `Void` と同じということだ．これはつまり $a \times  0 = 0$ ということだ．

自然数の加算・乗算と似ている例としてもうひとつ，分配則について考えよう．

$$ a \times (b + c) = a \times b + a \times c $$

こちらも，直和型・直積型で成り立つだろうか．答えは（例によって同型を除いて）イエスだ．左辺に対応する型はこうなる．

```haskell
(a, Either b c)
```

そして右辺に対応する型はこうだ．

```haskell
Either (a, b) (a, c)
```

左辺から右辺へ変換する関数は次のように書ける．

```haskell
prodToSum :: (a, Either b c) -> Either (a, b) (a, c)
prodToSum (x, e) =
    case e of
      Left  y -> Left  (x, y)
      Right z -> Right (x, z)
```

逆に右辺から左辺への変換はこうだ．

```haskell
sumToProd :: Either (a, b) (a, c) -> (a, Either b c)
sumToProd e =
    case e of
      Left  (x, y) -> (x, Left  y)
      Right (x, z) -> (x, Right z)
```

関数の中の `case of` 文でパターンマッチングをしている．それぞれのパターンにマッチングした場合，それに続く式が評価される．たとえば `prodToSum` に次の値を与えたとする．

```haskell
prod1 :: (Int, Either String Float)
prod1 = (2, Left "Hi!")
```

このとき， `case e` の `e` は `Left "Hi!"` になるので， `Left y` のパターンにマッチングし， `y` は `"Hi!"` になる． `x` はすでに `2` にマッチングしているので，`case of` 節の結果は期待通り `Left (2, "Hi!")` となる．

`prodToSum` と `sumToProd` が互いに逆になっているかはここでは確認しないが，そう見えるから多分そうだろう^[原文： if you think about it, they must be!]．結局，同じ情報を2種類のデータ構造に納めているだけなので，データは同じでフォーマットが違うだけのことだ．

数学の世界では，このようにふたつのモノイドが絡み合っているものを **半環** (semiring) と呼ぶ．型の減算に相当するものが定義されていないので「完全な」環ではない．そのため半環は，  n(egative) の無い ring という意味で *rig* とも呼ばれることもある．だがそれを差し引いても，rig をなす自然数などに関する文を，型に関する文に読み替えてみることのメリットは大きい．対応関係を表にまとめておこう．

| 自然数 | 型 |
|-------|----|
|0|`Void`|
|1|`()`|
|$a + b$|`Either a b = Left a | Right b|
|$a \times b$|`(a, b)` or `Pair a b = Pair a b`|
|$2 = 1 + 1$|`data Bool = True | False`|
|$1 + a$|`data Maybe = Nothing | Just a`|

この考え方を応用すると，興味深いことにリスト型が等式の解として定義できる．型定義において，等号の左右両方に定義したい型自身が登場するのだ．

```haskell
data List a = Nil | Cons a (List a)
```

先ほどと同様の置き換えに加え， `List a` を `x` に置き換えると，次の等式を得る．

```haskell
x = 1 + a * x
```

いま扱っている代数計算には減算や除算が定義されていないので，この式を `x` について解くことができない．そこで右辺の `x` を `(1 + a * x)` に置き換えて分配則を適用する，という作業を繰り返し行ってみよう．

```haskell
x = 1 + a*x
x = 1 + a*(1 + a*x) = 1 + a + a*a*x
x = 1 + a + a*a*(1 + a*x) = 1 + a + a*a*x + a*a*a*x
...
x = 1 + a + a*a + a*a*a + a*a*a*a...
```

最終的には無限級数が得られる．これを解釈するなら，「リストは空 (`1`)か，要素がひとつだけ (`a`) ^[原文： singleton] か，ペア (`a*a`) か，要素が3つのタプル (`a*a*a`)か… である」ということになる．これはまさにリストだ．

リストのような再帰的なデータ構造についてはもっといろいろあるのだが，それらについては関手と不動点を学んだあとに改めて話すことにする．

変数を含む等式を解くという作業は，代数によく似ている．これが，「代数データ型」という名前の由来だ．

最後に，型を代数的に解釈する際の注意点を一つ示しておく．二つの型 `a` と `b` の積は両方の型の値を含んでいなければならないので，`a` と `b` は両方とも値を持つ型でなければならない．一方，直和型の場合は `a` と `b` のどちらかの値を持てばよいので，どちらかが値を持つ型であれば良い．論理積と論理和も半環をなし，次のように対応づけられる．

|論理|型|
|---|---|
|$false$|`Void`|
|$true$ |`()`|
|$a \| b$ | `Either a b = Left a | Right b`|
|$a \&\& b$|`(a, b)`|

この対応関係を深堀していくと，論理と型理論の間のカリー＝ハワード同型対応にたどり着くのだが，これについては関数型のところで話すことにしよう．

（和訳：[@takase](https://zenn.dev/takase)）