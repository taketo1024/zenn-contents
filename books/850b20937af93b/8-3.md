---
title: "8.3 代数的データ型の関手性"
---

これまで，パラメータをとるデータ型が関手となっていて `fmap` を定義できるという例をいくつか見てきた．複雑なデータ型をシンプルなデータ型から作れる．とくに， **代数的データ型** (Algebraic Data Type: ADT) は和や積から組み立てることができる．和や積が関手的であるというのは既に見た．そして関手が結合的であることも既に知っている．ということは，ADT の基本パーツが関手的なら，パラメータをとる ADT も関手的だと言えるだろう．

パラメータをとる代数的データ型の基本パーツとはなんだろうか？ まず，関手の型パラメータに依存しない部品が必要だ． `Maybe` における `Nothing` や， `List` における `Nil` がこれに相当する．これらは `Const` 関手に対応する． `Const` 関手は型パラメータを無視する（正確には第2の型パラメータを無視し，第1の型パラメータは保持する）という関手だった．

もう一つの基本パーツとして，型パラメータを単に包むだけ，というものもある． `Maybe` の `Just` がこれに相当する．これは恒等関手に対応する．「恒等関手は圏の圏 $\mathbf{Cat}$ における恒等射である」という話は既にしたが，まだ Haskell で定義していなかったので書いておこう．

```haskell
data Identity a = Identity a
instance Functor Identity where
  fmap f (Identity x) = Identity (f x)
```

`Identity` は型 `a` の（変更不可能な）値を一つだけ保持するという，最もシンプルなコンテナだということが見えるだろう．

これら二つの基本パーツに対して積と和を使うことで，代数的データ型の残りが構成される．

この新しい知見をふまえて， `Maybe` 型コンストラクタを改めて眺めてみよう．

```haskell
data Maybe a = Nohting | Just a
```

これは二つの型の和であり，この和は関手的であるとわかる．ここで， `Nothing` は `Const ()` を `a` に作用させたものと書き直せる^[訳注 `data Const c a = Const c` なので `Const () a` はいかなる `a` に対しても常に `Const ()` を返す]．（ `Const` の第1型パラメータは単位元^[unit] に固定されているが，後ほど `Const` のより興味深い使用例が登場する．）また `Just a` は名前が違うだけで要するに恒等関手だ． ということは，`Maybe` を型コンストラクタでなく同型射を使って書き直せる．

```haskell
type Maybe a = Either (Const () a) (Identity a)
```

つまり， `Maybe` は双関手 `Either` に `Const ()` と `Identity` を組み合わせたものだということだ．（ `Const` は本当は双関手なのだが，ここでは部分適用した状態で使っている．）

ここまでで，関手を組み合わせたら関手になるということを見てきた．同様のことが双関手についても成り立つことは想像に難くない．これを確認するには，双関手の合成の，射に対するふるまいを確認すればよい．射のペアについて，まずそれぞれを関手で持ち上げる．これをさらに双関手で持ち上げたものが最終的な結果になる．

Haskell で書いてみよう．これから定義するデータ型に必要なパラメータは，双関手ひとつ（二つの型を引数にとる型コンストラクタ `bf` ），関手ふたつ（一つの型を引数にとる型コンストラクタ `fu`， `gu` ），そして単なる型ふたつ（ `a`，`b` ）だ．実体としては，まず `fu` を `a` に， `gu` を `b` に適用し，それらに `bu` を作用させる．

```haskell
newtype Bicomp bf fu gu a b = BiComp (bf (fu a) (gu b))
```

ここでやったことは，いわば対象 `a`，`b` の合成だ．また上の例でわかるように， Haskell では「型コンストラクタへ型を与える」のと「関数に引数を与える」のはまったく同じ見た目になる．これは覚えておくとよいだろう．

もうすこし理解を深めるのに良い例としては， `BiComp` に `Either`， `Const ()` ， `Identity`，`a`， `b` をこの順で与えたらどうなるか考えてみるといい．（`a` が無視されて） `Maybe b` になることがわかるだろう．

この新しいデータ型 `BiComp` が `a` と `b` の双関手となるためには， `bf` が `Bifunctor` （双関手）で， `fu` と `gu` が `Functor` （関手）でなければならない．つまりコンパイラは `bf` の `bimap ` が定義されていることを知っている必要がある． Haskell では，インスタンス宣言の `=>` の左側に前提条件として記述する．

```haskell
instance (Bifunctor bf, Functor fu, Functor gu) =>
  Bifunctor (BiComp bf fu gu) where
    bimap f1 f2 (BiComp x) = BiComp ((bimap (fmap f1) (fmap f2)) x)
```

`BiComp` の `bimap` の実装は， `fmap` した `fu` と `gu` を引数とする `bf` の `bimap` になっている．コンパイラはすべての（関数と変数の）型を推論し，適切な関数をオーバーロードする．

`bimap` の定義の中にでてくる `x` の型はこうだ．

```haskell
bf (fu a) (gu b)
```

`BiComp` の `bimap` 実装にはたくさんの意味が詰まっている^[原文：which is quite a mouthful.]．外側にある `bimap` は上位の `bf` の階層とつながっているし，二つの `fmap` は `fu` と `gu` の階層とそれぞれつながっている． `f1` と `f2` の型がそれぞれ，

```haskell
f1 :: a -> a'
f2 :: b -> b'
```

ならば， `bimap` の最終的な返り値の型は `bf (fu a') (gu b')` になる．

```haskell
bimap :: (fu a -> fu a') -> (gu b -> gu b')
  -> bf (fu a) (gu b) -> bf (fu a') (gu b')
```

じっくり時間をかけて楽しめるという点で，型操作はジグソーパズルを組み上げるのと似た感覚を覚えるかもしれない．

さて，ここまでの一連の議論で，我々は `Maybe` が関手であると証明する必要がないことがわかった．二つのより基本的な関手の直和であるということから示されるのだ^[訳注： `Maybe` は `Const ()` と `Identity` の直和（ `Either` ）なのだった．]．

鋭い読者は，次のような疑問を持つかもしれない．代数的データ型の `Functor` インスタンスがこんなに機械的に導けるなら，コンパイラで自動化できないものだろうか？ 実際これは可能だし，そういうものは存在する．次の行をソースの最初に追加することで， Haskell の機能拡張を有効にして，

```haskell
{-# LANGUAGE DeriveFunctor #-}
```

さらにデータ構造の後ろに `deriving Functor` をつければよい．つまり，こうだ．

```Haskell
data Maybe a = Nothing | Just a deriving Functor
```

これで必要な `fmap` が自動的に生成される．

代数的データ型の規則性を利用すれば， `Functor` 以外にもいくつかの型クラスに対して同様のことが可能だ．たとえば以前登場した `Eq` 型クラスがそれにあたる．ユーザ定義の型クラスに対してのインスタンスをコンパイラに明示的に与えることもできるが，これは少し高度な話になる．考え方は一緒で，基本パーツのふるまい，直和，そして直積を与えれば，コンパイラが残りを生成してくれる．


（和訳：[@takase](https://zenn.dev/takase)）