---
title: "6-3. 直和型"
---

集合の圏の積から直積型が産まれたように，余積から直和型を作ることができる．Haskell における直和型の標準的な実装はこうだ．

```haskell
data Either a b = Left a | Right b
```

ペアと同じように， `Either` も（同型を除いて）可換であり，入れ子にでき，入れ子の順序は（同型を除いて）任意である．たとえば要素が3つであれば，次のようにすればよい．

```haskell
data OneOfThree a b c = Sinistral a | Medial b | Dextral c
```

$\mathbf{Set}$ は余積を演算とするモノイダル圏^[さらに言えば対称モノイダル圏] である．このモノイダル圏では非交和が二項演算で，単位元が始対象だ．型で言うなら，演算子としての `Either` ^[訳注： 型コンストラクタの `Either` ではない] と，`Void` がそれぞれに相当する．実際， `Void` を足しても中身に変化は無い．たとえば `a` に `Void` を足したものを考えてみると，

```haskell
Either a Void
```

これは `a` と同型だ．なぜなら `Void` 型は値を持たないので `Either` の（右側の） `Right` コンストラクタからは何も作れず，（左側の） `Left` コンストラクタから作れるのはカプセルに包まれているだけで結局 `a` だからだ．数式で書くなら， $a+0=a$ という意味になる．

直和型は Haskell ではよく使われるが， C++ でこれに相当する union や　variant はそれほど使われない．この理由はいくつかある．

まず第1に， C++ で単純な直和型が欲しければ列挙型 `enum` を使えばよいという点が挙げられる．色についての直和型を Haskell と C++ のそれぞれで書くと次のようになる．

```haskell
data Color = Red | Green | Blue
```

```cpp
enum { Red, Green, Blue };
```

もっと単純に真偽値ならば Haskell では次のような表現になるのだが，

```haskell
data Bool = True | False
```

C++ ならばプリミティブな `bool` 型を使うことだろう．

値が存在するか否かを表現するのであれば， C++ では何らかの「ありえない」値を利用することが多い．空の文字列や負の値，ヌルポインタなどだ．これを避けたいのなら， Haskell では次のように `Maybe` 型を使う．

```haskell
data Maybe a = Nothing | Just a
```

`Maybe` 型は二つの型の直和である．それぞれについては問題なく理解できるだろう．ひとつめだけを抜き出すとこうなる．

```haskell
data NothingType = Nothing
```

`Nothing` だけを持つ列挙型で，要するにユニット型 `()` と等価なシングルトンだ．そしてふたつめだけ抜き出すとこうなる．

```haskell
data JustType a = Just a
```

型 `a` を包んでいるだけだ．以上をふまえると， `Maybe` は次のようにもかけることがわかる．

```haskell
data Maybe a = Either () a
```

より複雑な直和型の場合， C++ ではポインタを使うこともある．このポインタは null か，あるいは特定の型の値を指す．リストを例にすると， Haskell では（再帰的な）直和で定義される．

```haskell
data List a = Nil |  Cons a (List a)
```

これを C++ で扱うにはヌルポインタで空リストを表現する．

```cpp
template<class A>
class List {
    Node<A> * _head;
public:
    List() : _head(nullptr) {}
    List(A a, List<A> l)
      : _head(new Node<A>(a, l))
    {}
};
```

Haskell のコンストラクタ `Nil` と `Cons` は，オーバーロードされた `List` コンストラクタに対応する．（空なら `Nil`，値やリストなら `Cons`．） `List`クラスでは，直和型の二つの要素を区別するための目印は必要としないが，かわりに `nullptr` という特別な値を `_head` に入れることで `Nil` を表現する．

Haskell が C++ と大きく違うのは，値の上書きを許さない点だ．コンストラクタを使ってオブジェクトをつくったら，そのオブジェクトは自分が作られたときのコンストラクタの引数を永遠に忘れない．したがって一度 `Just "energy"` としてつくられた `Maybe` のオブジェクトが `Nothing` に変化することは絶対にない．同様に空リストは永遠に空リストであり，要素が3つのリストの要素数は常に3つだ．

この性質のおかげで，構成を逆にたどることができる．オブジェクトが与えられれば，そのオブジェクトがどのようにつくられたかまで必ず知ることができる．この操作はパターンマッチングでおこなうことができ，そのパターンはオブジェクトをつくったときのものが流用できる．`Nil` という空リストにマッチングするものと，`Cons` でつくられたリストにマッチングするものに分けられるだろう．たとえば `List` を取る関数 `maybeTail` を考える．

```haskell
maybeTail :: List a -> Maybe (List a)
maybeTail Nil = Nothing
maybeTail (Cons _ t) = Just t
```

`maybeTail` の定義の1行目ではコンストラクタ `Nil` にマッチングするものに対して `Nothing` を返すという定義している．2行目は，コンストラクタ `Cons` にマッチングしたら，興味の無い最初の部分をワイルドカード^[訳注: Haskell ではアンダースコア (_)] で捨てて，残りの部分を変数 `t` に束縛して `Just t` を返す．（ここでは便宜上変数と呼んでいるが，上書きできないので厳密には変数ではない．）その `List` がどのように作られたかによって，どちらにマッチングするかが決まる． `Cons` でつくられたなら，その時の2つの引数が取り出せるだろう．（そしてひとつ目は捨てられる．）

C++ では，直和型は多態性のクラス階層を使って実装される．同じ上位クラスを持つクラス群を一つの型とみなし，その vtable がタグのように働く．Haskell ではパターンマッチングでそれぞれのコードを呼び出すところを， C++ では仮想関数の呼び出しを使って vtable ポインタによりディスパッチするのだ．

C++ で `union` が直和型として使われているのを見ることはあまりないだろう．それは union に含めることができるものに様々な厳しい制限がかかっているせいだ．「コピーコンストラクタを持ってはならない」という制限もあるため `std::string` すら union には入れることができない．

（和訳：[@takase](https://zenn.dev/takase)）