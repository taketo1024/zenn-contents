---
title: "4.1 Writer圏"
---

既存の関数の返り値を装飾することで機能を付加する，という考え方はとても有用である．このような例はたくさんある．出発地点はおなじみの型と関数の圏で，対象は型のままで，射は「装飾付き関数」とする．

たとえば `int` を取り `bool` を返す関数 `isEven` を装飾するとする．これを射してとらえる．ここで重要なポイントは，関数はペアを返すが，射としては `int` から `bool` への射（ペアへの射ではない）と見るということだ．

```cpp
pair<bool, string> isEven(int n) {
    return make_pair(n % 2 == 0, "isEven ");
}
```

圏論のルールによれば，この射は `bool` からの射であれば何であれ合成出来なければならない．具体的には，以前登場した `negate` とは射の合成ができるはずだ．

```cpp
pair<bool, string> negate(bool b) {
    return make_pair(!b, "Not so! ");
}
```

だが，関数の合成にはひと手間必要だ．次のような手順を踏まねばならない．

```cpp
pair<bool, string> isOdd(int n) {
    pair<bool, string> p1 = isEven(n);
    pair<bool, string> p2 = negate(p1.first);
    return make_pair(p2.first, p1.second + p2.second);
}
```

我々が現在議論している「この圏」^[訳注：　本章の最後で名前がつけられるまで，便宜上「この圏」と呼ぶことにする．]における，射を合成するためのレシピはこうだ．

1．第1の射に対応する装飾付き関数を実行して第1の実行結果を得る．
2. その結果から第1要素を取り出して，第2の射に対応する装飾付き関数を実行して第2の実行結果を得る．
3. 第1の実行結果と第2の実行結果から，それぞれの第2成分（文字列）を取り出して連結する．
4. 第1要素が最終結果で，第2要素を連結した文字列とするペアを返す．

このレシピを C++ の高階関数にするなら，3つの型をパラメータとして持つテンプレートになる．この3つは，「この圏」の対象に対応している．この高階関数は，前述のレシピで合成可能な2つの装飾付き関数を引数にとり，新たに第3の装飾済み関数を返す．

```cpp
template<class A, class B, class C>
function<Writer<C>(A)> compose(function<Writer<B>(A)> m1,
                               function<Writer<C>(B)> m2)
{
    return [m1, m2](A x) {
        auto p1 = m1(x);
        auto p2 = m2(p1.first);
        return make_pair(p2.first, p1.second + p2.second);
    }
}
```

このテンプレートを，先ほどの `toUpper` と `toWords` の合成の例に適用するとこうなる．

```cpp
Writer<vector<string>> process(string s) {
    return compose<string, string, vector<string>>(toUpper, toWords)(s);
}
```

だが `compose` テンプレートにいちいち型を渡さねばならないのは煩わしい．この問題は，返り値の型推論つきの汎用ラムダ関数に対応した C++14 対応コンパイラを使えば回避できる．（次のコードは Eric Niebler によるものだ．）

```cpp
auto const compose = [](auto m1, auto m2) {
    return [m1, m2](auto x) {
        auto p1 = m1(x);
        auto p2 = m2(p1.first);
        return make_pair(p2.first, p1.second + p2.second);
    }
}
```

この新しい `compose` を使えば，関数 `prosess` は次のようにシンプルになる．

```cpp
Writer<vector<string>> process(string s) {
    return compose(toUpper, toWords)(s);
}
```

だがまだ終わりではない．「この圏」に対して合成は定義したが，恒等射はどうだろうか．これは今まで見てきた恒等射とは違うものになる！ この恒等射は，型 A から型 A への射であり，つぎのような形になる．

```cpp
Writer<A> identity(A);
```

また，この恒等射は合成について単位元の役割を果たさねばならない．合成の定義からすると，この恒等射は引数をそのまま返し，ログにも何も加えないでいるべきだ．

```cpp
template<class A> Writer<A> identity(A x){
    return make_pair(x, "");
}
```

「この圏」が圏のルールを守っているかは容易に確認できるだろう．とくに合成が結合律を満たすことはすぐにわかる．それぞれのペアの第1要素だけに注目すれば単なる関数合成なので結合的だし，第2要素は文字列の連結なのでこちらも結合的だ．

このような構成が文字列モノイドに限らず任意のモノイドに一般化できるのではないか，と気づいた読者はとても鋭い． `compose` の `+` を `mappend` に， `identity` の `""` を`mempty` に置き換えれば，文字列でないログを生成することも可能になる．優れたライブラリ作成者は，ライブラリが機能するための最小限の制約を見極めることができるものだ．このログ生成ライブラリについていえば，最小限の制約とは，ログがモノイド的である，ということだ．

（和訳：[@takase](https://zenn.dev/takase)）