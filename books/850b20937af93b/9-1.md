---
title: "9.1 普遍的構成"
---

これ以降しばらくの間，関数型が集合だということを忘れて，関数型，より一般的に言えば内部 hom 集合を構成することに挑戦してみよう．例によって圏 $\mathbf{Set}$ から考え始めるのだが，あとでほかの圏に応用したいので，集合自身の性質を利用してしまわないように注意が必要だ．

関数型とは「引数の型」と「値の型」の間の関係であるので，合成された型と見ることができる．合成された型（つまり対象間の関係を示す型）といえば，以前に普遍的構成を使って積と余積の型を定義したことがあった．おなじテクニックを関数型に適用してみよう．必要なのは3つの型のパターン，つまりこれから構成しようとする関数の型と，引数の型，そして値の型の3つである．

これらの3つをつなぐパターンは， **関数適用** (function applicaiton) または **評価** (evaluation) と呼ばれる．関数型 $z$ （これは $\mathbf{Set}$ 以外の圏を考えている場合には単なる対象である^[?]）とその引数の型 $a$ （対象）が与えられたとき，関数適用という操作は $z$ と $a$ のペアを値の型 $b$ （対象）にマッピングする．この3つの対象のうち，引数の型と値の型は固定されている．

いわゆる「マッピング」も関数適用のひとつである．先ほどのパターンに当てはめてみよう．もし対象の中を覗けるのであれば，関数 $f$ （これは型 $z$ の要素だ）と引数 $x$ （これは型 $a$ の要素）のペアを $f x$ （$x$ に $f$ を適用したもので，型 $b$ の要素）にマッピングするという作業はまさに関数適用である．

![](https://storage.googleapis.com/zenn-user-upload/73c3f4c2dee8bdd1a1b0fe67.jpg) *$\mathbf{Set}$ において，関数の集合 $z$ から $f$ を選び，集合（型） $a$ から引数として $x$ を選び， 集合（型） $b$ の要素 $fx$ を値として得る．*

しかし， $(f,x)$ という具体的なペアの代わりに，関数型 $z$ とその引数型 $a$ の積全体について議論することもできる．積 $z \times a$ という対象から対象 $b$ への射 $g$ を，「適用」射として考えるのだ． $\mathbf{Set}$ で考えるなら  $g$ は $(f,x)$ から $fx$ への関数になるだろう．

以上をまとめると，「対象 $z$ と対象 $a$ の積から他の対象 $b$ への射 $g$ 」が今回のパターンということになる．

![](https://storage.googleapis.com/zenn-user-upload/b4a518edcf56ca93cec1248c.jpg) *対象と射のパターン（普遍的構成の第1ステップ）*

さて，このパターンは，普遍性構成によって関数型を特定するのに十分だろうか？ 任意の圏に対しては十分というわけではないが，我々の興味の対象である圏については問題ない．もう一つの疑問は，積を定義せずに**関数対象** (function object)を定義できるか，というものだ．圏の中には積が存在しないものもあるし，任意の対象のペアが積というわけでもない．これに対する答えは No だ．積がなければ関数型は無い．これについては冪を議論する際に触れる．

普遍的構成について復習しよう．第1ステップは対象と射のパターンを決めることだ．今回は先ほど決めたパターンを使うわけだが，これはあいまいなクエリーで，ヒットする候補が非常に多い^[訳注：本書では普遍的構成を[web検索に例えて](https://zenn.dev/taketo1024/books/850b20937af93b/viewer/5-0)説明している．]．特に $\mathbf{Set}$ ではほぼ全ての対象の対象がすべての対象につながっている．よって任意の対象 $z$ について $a$ との積を構成できて，さらにその積から $b$ への関数が存在する（ただし $b$ が空集合の場合を除く）．

ここで第2ステップとして，秘密兵器「順位付け」を導入する．そのためには候補となる対象の間に，今回のパターンを分解するようなマッピングがただ一つ存在することが必要である．ここでは， $z$ と $g$ （これは $z \times a$ から $b$ への射）が，他の $z'$ と $g'$ よりも「上位である」と言いたい．（ヒント：次の図を見ながらこの文を読み返してみてほしい）

![](https://storage.googleapis.com/zenn-user-upload/3093740628504347fb49cba1.jpg) *関数の候補の間の順位付け*

ここからが少しややこしい．（関数型に関する普遍的構成が満を持しての登場となったのはこのためだ．）まずは射 $h :: z' \rightarrow z$ をつかって，図式の $z' \times a$ と $z \times a$ の間をつなぎたい．我々は既に積が関手的であると知っているので，このマッピングを作ることができる．積はそれ自身が関手（もっと言えば自己関手であり双関手）だったので，射のペアを持ち上げることができる．別の言い方をすれば，対象の積にくわえて，射の積が定義できるということだ．

積 $(z' \times a)$ の二つ目の要素 $a$ には何もしないので，持ち上げられる射は $(h, \mathbf{id})$ だ．ここで $\mathbf{id}$ は $a$ の恒等射である．

これを使うと，適用 $g'$ から $g$ をくくりだすことができる．

$$ g' = g \circ (h \times \mathbf{id}) $$

ポイントは射の積を使ったところだ．

普遍的構成の第3ステップは，普遍性を持つ，つまりベストな対象を見つけるという作業だ．このベストな対象を $a \Rightarrow b$ と呼ぶことにしよう．（ Haskell の型クラス制約と紛らわしいが，あくまで特定の対象を表す記号だ．別の書き方もあるが，後で触れる．）この対象は専用の適用射 $eval$ （つまり $(a \Rightarrow b) \times a$ から $b$ への射）とセットになっている．対象 $a \Rightarrow b$ が普遍性を持つ，つまり他のどの候補よりも「上位である」と言うためには，他の全ての関数対象の候補が，その適用射 $g$ を $eval$ で分解することによって，$a \Rightarrow b$ に一意にマッピングできればよい．

![](https://storage.googleapis.com/zenn-user-upload/a758c72749b1d8c0df4920ae.jpg) *普遍的な関数対象の定義．対象 $a \Rightarrow b$ が普遍性を持つことを除けば，ひとつ前の図式とおなじである．*

整理すると，

----
$a$ から $b$ への関数対象とは，対象 $a \Rightarrow b$ と射 $eval$ 

$$ eval :: ((a \Rightarrow b) \times a) \rightarrow b$$

であって，
任意の対象 $z$ を用いた射 $g$ 

$$ g :: z \times a \rightarrow b $$

を， $h$ と $eval$ を使い，

$$ g = eval \circ (h \times \mathbf{id}) $$

と分解できるような射 $h$

$$ h :: z \rightarrow (a \Rightarrow b) $$

がただ一つ存在するものをいう．

----


任意の圏の任意の対象のペア $a$ と $b$ に対して $a \Rightarrow b$ が必ず存在するという保証はないが， $\mathbf{Set}$ には $a \Rightarrow b$ が存在し，それは hom 集合 $\mathbf{Set}(a,b)$ と同型である．

これが，Haskell の関数型 `a -> b` が圏論の関数対象 $a \Rightarrow b$ である，と解釈できる理由だ．





（和訳：[@takase](https://zenn.dev/takase)）