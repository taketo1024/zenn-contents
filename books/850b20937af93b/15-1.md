---
title: "15.1 Haskellでの米田"
---

我々はすでにHaskellで，Reader関手の装いをしたHom関手に出会っている:

```haskell
type Reader a x = a -> x
```

Readerは射(ここでは関数)を前への合成によって写す:

```haskell
instance Functor (Reader a) where
    fmap f h = f . h
```

米田の補題は，Reader関手は自然にどんな他の関手にも写せるということを教えてくれる．

自然変換は多相関数である．なので，関手`F`が与えられると，そこへのReader関手からの写像ができる:

```haskell
alpha :: forall x . (a -> x) -> F x
```

いつもどおり`forall`はオプションだが，自然変換でできたパラメータ多相であることを明示的に強調するために，私は書いておくほうが好きだ．

米田の補題はこれら自然変換が`F a`の元と一対一対応にあるということを教えてくれる:

```haskell
forall x . (a -> x) -> F x ≅ F a
```

この等式の右辺は普通，データ構造と考えるものである．関手の解釈は一般化されたコンテナだということを覚えているだろうか？`F a`は`a`のコンテナである．しかし，左辺は関数を引数として取る多相関数である．米田の補題はこの2つの解釈は等価であること---同じ情報を持っていること---を教えてくれる．

別の言いかたはこうだ: 次の型の多相関数を与えよ:

```haskell
alpha :: forall x . (a -> x) -> F x
```

さすれば`a`のコンテナを与えよう．トリックは米田の補題の証明で使ったやつだ: この関数を`id`で呼びだし，`F a`の元を得る:

```haskell
alpha id :: F a
```

逆もまた真である: `F a`型の値を与えられると:

```haskell
fa :: F a
```

正しい型の多相関数が定義できる:

```haskell
alpha h = fmap h fa
```

これら2つの表現を行ったり来たりできるのだ．

複数の表現ができることの利点は，一方は他方より合成が簡単かもしれず，また一方は他方より応用上効率的かもしれないことだ．

この原理の最も簡単な実例は，コンパイラの構成でしばしば用いられるコード変換である，継続渡しスタイル(Continuation Passing Style, 略してCPS)である．これは米田の補題の最も簡単な応用であり，恒等関手に適用したものである:

```haskell
forall r . (a -> r) -> r ≅ a
```

この公式は，どんな型`a`も`a`の「ハンドラ」を取る関数で置き換えることができると解釈できる．ハンドラは`a`を受け付ける関数で，計算の残りを実行するもの---継続である(型`r`は普通，なんらかの状態コードをカプセル化している)．

このスタイルのプログラミングはUIや非同期システム，並行プログラミングではとてもよくあることである．CPSの欠点は，制御の逆転を含んでいることである．コードは生産者と消費者(ハンドラ)に分割され，それらは容易には合成できない．自明でないWebプログラミングを少しでもやったことのある人にとっては，状態を持つハンドラとやりとりするスパゲティコードの悪夢はおなじみだろう．後でみるように，関手とモナドを賢く使えば，CPSに合成の性質をいくらか取り戻すことができる．



（和訳：[@ashiato45](https://twitter.com/ashiato45)）
