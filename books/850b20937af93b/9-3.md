---
title: "9.3 指数対象"
---

数学の文献では，関数対象または二つの対象 $a$ と $b$ の間の内部 hom 対象は **指数対象** (exponential) と呼ばれれ， $b^a$ と表記する．引数を指数部に置くわけだ．この記法は最初のうちは奇妙に見えるかもしれないが，関数と積の間の関係を理解していくと，合理的な記法であることがわかるだろう．内部 hom 対象の普遍的構成としての積の必要性は見てきたが，積の重要性はこれにとどまらない．

この記法は，有限型（`Bool`，`Char`，そして `Int`，`Double` のような値が有限個の型）から有限型への関数を考えるときに特に便利だ．このような関数は，少なくとも原理的には完全にメモ化できるし，データ構造に落とし込むこともできる．これは，関数という射と，関数型という対象とが等価であるという本質を示している．

例えば `Bool` を取る（純粋な）関数は2つの値で特徴づけられる． `False` に対する値と， `True` に対する値だ．たとえば `Bool` を取り `Int` を返す関数をすべて集めた集合を考えたとすると，これはつまりあらゆる組み合わせの `Int` のペアの集合である．これはつまり `Int` $\times$ `Int` ということだが，より想像力を柔軟に働かせると $\mathrm{Int}^2$ と書いてもよさそうだ．

別の例として， C++ の `char` 型を例にとってみよう． `char` 型は 256 の値を持つ（Haskell の `Char` は Unicode なのでもっと多い）． C++ 標準ライブラリにも，ルックアップテーブルで実装された関数がいくつか存在する． `isupper` や `isspace` はテーブルで実装されていて，実体は 256 個の真偽値のタプルになっている．タプルは積の型だったから， 256 個の真偽値の積（ `bool` $\times$ `bool` $\times$  `bool` $\times$ ... $\times$ `bool`  ）ということだ．代数演算的には，積の繰り返しはべき乗の定義だったから， `bool` を 256 回 （あるいは `char` 回）くりかえし「かけた」ものは， `bool` の `char` 乗，つまり $\mathrm{bool^{char}}$ と書いてもよさそうだ．

ところで， 「256 個の `bool` のタプル」にはいくつの値が含まれているのだろうか．答えは $2^{256}$ だ．これは，定義しうるすべての相異なる `char` から `bool` への関数の数でもある．関数ひとつが， 256 要素のタプルひとつに対応する．これと同じ考え方をつかえば，例えば `bool` から `char` への関数の数が $256^2$ であると計算できる．関数型を指数の形で表現する利点をご理解いただけただろうか．

関数とデータ型が等価であることはわかったが， `int` から `double` への関数をメモ化するというのは実用的でないかもしれない．リスト型や文字列型，ツリー型などの型をメモ化しようとすると，無限のストレージが必要になってしまう．しかし 遅延評価を持つ Haskell のような言語では，遅延評価される（無限長の）データ構造と関数の区別はあいまいだ．このような関数とデータの双対性は，Haskell の関数型と圏論の指数対象が同じものであることを教えてくれるし，私たちが持っている「データ」という概念をさらに豊かにしてくれる．

（和訳：[@takase](https://zenn.dev/takase)）