---
title: "8.5 Writer 関手"
---

前に，「クライスリー圏に戻ってくる」と約束した．クライスリー圏の射は，データ型 `Writer` を返す「装飾のついた」関数である．

```haskell
type Writer a = (a, String)
```

前に述べたように，この装飾部分は自己関手と少し関係している．そして実際のところ， `Writer` 型コンストラクタは `a` について関手的だ．これは単なる直積型なので， `fmap` を自分で実装する必要はない．

しかし，クライスリー圏と関手にはどんな関係があるのだろうか？ クライスリー圏とは圏の一種で，合成と恒等関手を持つのだった．この合成はフィッシュ演算子 (fish operator) で与えられることを思い出しておこう．

```haskell
(>=>) :: (a -> Writer b) -> (b -> Writer c) -> (a -> Writer c)
m1 >=> m2 = \x ->
  let (y, s1) = m1 x
      (z, s2) = m2 y
  in (z, s1 ++ s2)
```

恒等射は `return` と呼ばれる関数で与えられる．

```haskell
return :: a -> Writer a
return x = (x, "")
```

これら二つの関数をよーーーく眺めると， `fmap` の型シグネチャに合うようにまとめられることがわかるだろう．こうだ．

```haskell
fmap f = id >=> (\x -> return (f x))
```

フィッシュ演算子は二つの関数を結合している．ひとつは慣れ親しんだ `id` で，もうひとつは引数に対して `f` を適用した結果を `return` するという無名関数だ．一番ひっかかるのは `id` の使われ方だろう．フィッシュ演算子の引数は，「普通の」型を取って装飾された型を返す関数と思っている読者がいるかもしれないが，実はそうでもない．一体いつから `a -> Writer b` の `a` が「普通の」型だと錯覚していた？ `a` は型変数であり，何でもよいのだ．たとえば `Writer b` のように装飾された型でもよいのだ．

`id` は `Writer a` をとったら `Writer a` を返す．フィッシュ演算子は `a` の値をつり上げて^[原文： fish out]，無名関数の `x` として渡す．そして `f` は `b` を返し，それを `return` が装飾して `Writer b` を作る．つまり `id` は `Writer a` を取って `Writer b` を返すということになり，これはまさに `fmap` だ．

気をつけたいのは，この引数はとても汎用的だということだ． `Writer` を任意の他の型コンストラクタに置き換えることもできる．フィッシュ演算子と `return` をサポートしてさえいれば， `fmap` を定義できるのだ．だからクライスリー圏による装飾は関手になれる．（が，すべての関手がクライスリー圏になれるわけではない．）

自前で実装した `fmap` とコンパイラが `deriving` で導出した `fmap` が同じものか不安になる読者もいるかもしれない．興味深いことに，その心配はいらない．これは，Haskell での多相型関数の実装方法に関係している．これはいわゆる **パラメータ多相** (parametric polymorphism) で， "theorems for free" に由来するものだ．その理論によれば，所与の型コンストラクタに対する `fmap` が存在し，それが恒等射を保つなら，それは一意でなければならない．

（和訳：[@takase](https://zenn.dev/takase)）