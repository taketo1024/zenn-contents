---
title: "4. クライスリ圏"
---
原文：[4. Kleisli Categories](https://bartoszmilewski.com/2014/12/23/kleisli-categories/)

型や純粋関数を圏としてモデリングする方法について議論した際に，副作用や純粋でない関数についてもモデリングできると述べた．その一つの例として，自身の実行ログや履歴を出力する関数について考えてみよう．命令型言語の場合は，グローバルな状態変数を更新することになるだろう．

```cpp
string logger;

bool negate(bool b) {
    logger += "Not so!";
    return !b;
}
```

これが純粋関数でないことは一目でわかる．純粋関数ならメモ化できるはずだが，仮にこの関数をメモ化しようとしたらログの生成はうまくいかない．つまり，この関数は **副作用** (side effects) を持っているのだ．

モダンなプログラミングではグローバル変数の更新を極力避ける．その理由は，並列実行が複雑になるというだけでも十分だろう．さらにはコードのライブラリ化もできない．

都合の良いことに，副作用のある関数を純粋関数に変換できる．ログを引数の一つとして明示的に扱えばよいのだ．返り値は本来の出力と更新された文字列のペアにすればよい．

```cpp
pair<bool, string> negate(bool b, string logger) {
    return make_pair(!b, logger + "Not so! ");
}
```

これで副作用は消え，関数は純粋になった．おなじ引数を与えたらいつでもおなじ値と文字列を返してくれるし，必要とあらばメモ化も可能だ．しかしログは実行のたびに蓄積されるので，メモ化の際には起こりうる引数の履歴の組み合わせ全てに対して保存が必要となる．たとえば，

```cpp
negate(true, "It was the best of times. ");
```

や，

```cpp
negate(true, "It was the worst of times. ");
```

などを，別々にメモしておかねばならないということだ．

また，このインターフェースはライブラリ関数としてはいまいちだ．返り値の方の文字列を無視できるので大きな問題はないが，引数の文字列は省略できない．これはとても不便だ．

もうすこしスマートにする方法はないものだろうか．問題を切り分けることはできないだろうか．今回のようなシンプルな例では，関数 `negate` の一番の目的はある真偽値を受け取ってその逆を返すことで，ログの生成機能は付加的なものだ．そして，「メッセージを生成する機能」は関数固有だが，「メッセージを一つのログファイルにまとめる機能」はそうではない．そこで，この作業の重荷から関数を解放してあげよう．妥協案としては次のようになる．

```cpp
pair<bool, string> negate(bool b) {
    return make_pair(!b, "Not so! ");
}
```

このアイディアの要点は，ログをまとめる機能を関数の外側に出したことだ．

これをどうやって実現するか考えるために，もう少し現実にありそうな例を見てみよう．小文字を大文字に変換するという関数 `toUpper` と，

```cpp
string toUpper(string s) {
    string result;
    int (*toupperp)(int) = &toupper; // toupper is overloaded
    transform(begin(s), end(s), back_inserter(result), toupperp);
    return result;
}
```

文字列を空白で分割して文字列ベクターにする関数 `toWords` があったとしよう．

```cpp
vector<string> toWords(string s) {
    return words(s);
}
```

作業の本体は補助関数 `words` で行われる．

```cpp
vector<string> words(string s) {
    vector<string> result{""};
    for (auto i = begin(s); i != end(s); ++i)
    {
        if (isspace(*i))
            result.push_back("");
        else
            result.back() += *i;
    }
    return result;
}
```

さて， `toUpper` と `toWords` を改造して，元々の返り値の背中にこっそりメッセージを乗せてみよう．

![](https://storage.googleapis.com/zenn-user-upload/be7d272a86585b2259d5370e.jpg)

いわば，2つの関数の返り値を「装飾する」のだ．そのための汎用的な道具として `Writer` というテンプレートを新たに定義しよう．この `Writer` テンプレートはペアをカプセル化していて，ひとつめの要素は任意の型 `A` で，ふたつめの要素は文字列になっている．

```cpp
template<class A>
using Writer = pair<A, string>;
```

これを使って関数を装飾する．

```cpp
Writer<string> toUpper(string s) {
    string result;
    int (*toupper)(int) = &toupper;
    transform(begin(s), end(s), back_inserter(result), toupperp);
    return make_pair(result, "toUpper ");
}

Writer<vector<string>> toWords(string s) {
    return make_pair(words(s), "toWords ");
}
```

この装飾付き関数を組み合わせると，「文字列を大文字にしてから単語ごとに分割し，その操作を記録する」という関数ができる．

```cpp
Writer<vector<string>> process(string s) {
    auto p1 = toUpper(s);
    auto p2 = toWords(p1.first);
    return make_pair(p2.first, p1.second + p2.second);
}
```

これで目的が達成できた．ログをまとめる作業はもはや個々の関数の役割ではない．それぞれの関数は自身のメッセージだけを生成すればよく，それらは関数の外側で連結される．

このような，関数をつなげてい新たな関数をつくるスタイルをプログラム全体に適用すると，くりかえしだらけでミスしやすい悪夢のようなコードになる懸念がある．だが我々はプログラマーだ．そこにくりかえしがあるなら，抽象化してしまえばいい．注意すべきなのは，抽象化したいのが「関数の合成」だという点だ．合成は圏論の肝なので，コードを書き進める前に圏論的な視点でこの問題を眺めてみよう．

（和訳：[@takase](https://zenn.dev/takase)）